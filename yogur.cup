/* Jorge Osés Grijalba
 * Álvaro Rodríguez García
 */

package yogur.cup;

import java_cup.runtime.*;
import java.util.*;

import yogur.error.CompilationException;
import yogur.tree.*;
import yogur.tree.declaration.*;
import yogur.tree.declaration.declarator.*;
import yogur.tree.expression.*;
import yogur.tree.expression.identifier.*;
import yogur.tree.statement.*;
import yogur.tree.type.*;

scan with {: return getScanner().next_token(); :};

parser code {:
	private List<CompilationException> exceptions = new ArrayList<>();

	public List<CompilationException> getExceptions() {
		return exceptions;
	}

	public void syntax_error(Symbol symbol) {
		exceptions.add(new CompilationException(symbol, CompilationException.Scope.SyntacticalAnalyzer));
	}
:}

terminal INT, BOOL, ID, TYPE, DELIMITER, COMMA;
terminal ASSIGN, SUM, SUBS, PROD, DIV, MOD, AND, OR, NOT, DOT, LRANGE, RRANGE, EQ, NEQ, GEQ, GT, LEQ, LT, COLON, ARROW;
terminal LPAREN, RPAREN, LSQUARE, RSQUARE, LBRACKET, RBRACKET;
terminal DEF, VAR, CLASS, IF, ELSE, WHILE, FOR, IN, TO;

non terminal S, Inst, Dec, DVar, DVarN, DProc, DFunc, DClass, Block;
non terminal If, While, For, Ass;
non terminal Exp, Exp0, Exp1, Exp2, Exp3, Exp4, Exp5, Exp6, Exp7;
non terminal Op, Op0, Op1, Op2, Op3, Op4, Op5;
non terminal Declarator, Declarator0;
non terminal VarType, Index, CommaExp, ArgList, Args, Arg, ClassBody, BlockBody, Else;


S ::= S:p DELIMITER Inst:i				{: RESULT = new Program((Program)p, (StatementOrDeclaration)i); :}
	| S:p DELIMITER Dec:d				{: RESULT = new Program((Program)p, (StatementOrDeclaration)d); :}
	| S:p DELIMITER DClass:d			{: RESULT = new Program((Program)p, (StatementOrDeclaration)d); :}
	| S:p DELIMITER						{: RESULT = p; :}
	| Inst:i							{: RESULT = new Program((StatementOrDeclaration)i); :}
	| Dec:d 							{: RESULT = new Program((StatementOrDeclaration)d); :}
	| DClass:d 							{: RESULT = new Program((StatementOrDeclaration)d); :}
	| 									{: RESULT = new Program(); :}
;
Inst ::= If:i							{: RESULT = i; :}
	| While:i							{: RESULT = i; :}
	| For:i								{: RESULT = i; :}
	| Ass:i								{: RESULT = i; :}
	| Block:i							{: RESULT = i; :}
	| DVar:i							{: RESULT = i; :}
;
Dec ::= DProc:d							{: RESULT = d; :}
	| DFunc:d							{: RESULT = d; :}
;

DVar ::= VAR Arg:a														{: RESULT = new VarDeclaration((Argument)a); ((AbstractTreeNode)RESULT).setLineCol(aleft, aright); :}
	| VAR Arg:a ASSIGN Exp:e											{: RESULT = new VarDeclaration((Argument)a, (Expression)e); ((AbstractTreeNode)RESULT).setLineCol(aleft, aright); :}
;
DVarN ::= VAR Arg:a														{: RESULT = new VarDeclaration((Argument)a); ((AbstractTreeNode)RESULT).setLineCol(aleft, aright); :}
;
DProc ::= DEF ID:id LPAREN ArgList:args RPAREN Block:b					{: RESULT = new FuncDeclaration((String)id, (List<Argument>)args, (Block)b); ((AbstractTreeNode)RESULT).setLineCol(idleft, idright); :}
;
DFunc ::= DEF ID:id LPAREN ArgList:args RPAREN ARROW Arg:rarg Block:b	{: RESULT = new FuncDeclaration((String)id, (List<Argument>)args, (Argument)rarg, (Block)b); ((AbstractTreeNode)RESULT).setLineCol(idleft, idright); :}
;
DClass ::= CLASS TYPE:t LBRACKET ClassBody:insts RBRACKET				{: RESULT = new ClassDeclaration((String)t, (List<FunctionOrVarDeclaration>)insts); ((AbstractTreeNode)RESULT).setLineCol(tleft, tright); :}
;
Block ::= LBRACKET BlockBody:insts RBRACKET								{: RESULT = new Block((List<Statement>)insts); :}
;

If ::= IF Exp:exp Block:b Else:elsee		{: RESULT = new IfStructure((Expression)exp, (Block)b, (Block)elsee); :}
;
Else ::= ELSE If:ife						{: List<Statement> insts = new ArrayList<Statement>(); insts.add((IfStructure)ife); RESULT = new Block(insts); :}
	| ELSE Block:b							{: RESULT = b; :}
	| 										{: RESULT = null; :}
;
While ::= WHILE Exp:e Block:b				{: RESULT = new WhileStructure((Expression)e, (Block)b); :}
;
For ::= FOR ID:id IN Exp:start TO Exp:end Block:b		{: RESULT = new ForStructure(new BaseDeclarator((String)id), (Expression)start, (Expression)end, (Block)b); :}
;
Ass ::= Declarator:d ASSIGN:eq Exp:e			{: RESULT = new Assignment((Declarator)d, (Expression)e); ((AbstractTreeNode)RESULT).setLineCol(eqleft, eqright); :}
;

Declarator ::= Declarator:d DOT:dt ID:id		{: RESULT = new DotDeclarator((Declarator)d, (String)id); ((AbstractTreeNode)RESULT).setLineCol(dtleft, dtright); :}
	| Declarator:d Index:i						{: RESULT = new ArrayDeclarator((Declarator)d, (ArrayIndex)i); ((AbstractTreeNode)RESULT).setLineCol(ileft, iright); :}
	| Declarator0:d								{: RESULT = d; :}
;
Declarator0 ::= LPAREN Declarator:d RPAREN		{: RESULT = d; :}
	| ID:id										{: RESULT = new BaseDeclarator((String)id); ((AbstractTreeNode)RESULT).setLineCol(idleft, idright); :}
;

Exp ::= Exp:e1 Op:o Exp0:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, (BinaryOperation.Operator)o); ((AbstractTreeNode)RESULT).setLineCol(oleft, oright); :}
	| Exp0:e					{: RESULT = e; :}
;
Exp0 ::= Exp0:e1 Op0:o Exp1:e2	{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, (BinaryOperation.Operator)o); ((AbstractTreeNode)RESULT).setLineCol(oleft, oright); :}
	| Exp1:e					{: RESULT = e; :}
;
Exp1 ::= Exp1:e1 Op1:o Exp2:e2	{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, (BinaryOperation.Operator)o); ((AbstractTreeNode)RESULT).setLineCol(oleft, oright); :}
	| Exp2:e					{: RESULT = e; :}
;
Exp2 ::= Exp2:e1 Op2:o Exp3:e2	{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, (BinaryOperation.Operator)o); ((AbstractTreeNode)RESULT).setLineCol(oleft, oright); :}
	| Exp3:e					{: RESULT = e; :}
;
Exp3 ::= Exp3:e1 Op3:o Exp4:e2	{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, (BinaryOperation.Operator)o); ((AbstractTreeNode)RESULT).setLineCol(oleft, oright); :}	
	| Exp4:e					{: RESULT = e; :}
;
Exp4 ::= Exp4:e1 Op4:o Exp5:e2	{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, (BinaryOperation.Operator)o); ((AbstractTreeNode)RESULT).setLineCol(oleft, oright); :}
	| Exp5:e					{: RESULT = e; :}
;
Exp5 ::= Op5:o Exp5:e			{: RESULT = new UnaryOperation((Expression)e, (UnaryOperation.Operator)o); ((AbstractTreeNode)RESULT).setLineCol(oleft, oright); :}
	| Exp6:e					{: RESULT = e; :}
;
Exp6 ::= Exp6:e DOT:d ID:id					{: RESULT = new DotIdentifier((Expression)e, (String)id); ((AbstractTreeNode)RESULT).setLineCol(dleft, dright); :}
	| Exp6:e Index:i						{: RESULT = new ArrayIdentifier((Expression)e, (ArrayIndex)i); ((AbstractTreeNode)RESULT).setLineCol(ileft, iright); :}
	| Exp6:e LPAREN:l CommaExp:exps RPAREN	{: RESULT = new FunctionCall((Expression)e, (List<Expression>)exps); ((AbstractTreeNode)RESULT).setLineCol(lleft, lright); :}
	| Exp6:e LPAREN:l RPAREN				{: RESULT = new FunctionCall((Expression)e, new ArrayList<Expression>()); ((AbstractTreeNode)RESULT).setLineCol(lleft, lright); :}
	| Exp7:e								{: RESULT = e; :}
;
Exp7 ::= LPAREN Exp:e RPAREN	{: RESULT = e; :}
	| ID:id						{: RESULT = new BaseIdentifier((String)id); ((AbstractTreeNode)RESULT).setLineCol(idleft, idright); :}
	| INT:intLit				{: RESULT = new Constant(intLit); ((AbstractTreeNode)RESULT).setLineCol(intLitleft, intLitright); :}
	| BOOL:boolLit				{: RESULT = new Constant(boolLit); ((AbstractTreeNode)RESULT).setLineCol(boolLitleft, boolLitright); :}
;

Op ::= OR		{: RESULT = BinaryOperation.Operator.OR; :}
;
Op0 ::= AND		{: RESULT = BinaryOperation.Operator.AND; :}
;
Op1 ::= EQ		{: RESULT = BinaryOperation.Operator.EQ; :}
	| NEQ		{: RESULT = BinaryOperation.Operator.NEQ; :}
;
Op2 ::= LT		{: RESULT = BinaryOperation.Operator.LT; :}
	| LEQ		{: RESULT = BinaryOperation.Operator.LEQ; :}
	| GT		{: RESULT = BinaryOperation.Operator.GT; :}
	| GEQ		{: RESULT = BinaryOperation.Operator.GEQ; :}
;
Op3 ::=	SUM		{: RESULT = BinaryOperation.Operator.SUM; :}
	| SUBS		{: RESULT = BinaryOperation.Operator.SUBS; :}
;
Op4 ::= PROD	{: RESULT = BinaryOperation.Operator.PROD; :}
	| DIV		{: RESULT = BinaryOperation.Operator.DIV; :}
	| MOD		{: RESULT = BinaryOperation.Operator.MOD; :}
;
Op5 ::= SUBS	{: RESULT = UnaryOperation.Operator.NEG; :}
	| NOT		{: RESULT = UnaryOperation.Operator.NOT; :}
;

VarType ::= VarType:t LSQUARE INT:i RSQUARE		{: RESULT = new ArrayType((Type)t, (Integer)i); :}
	| TYPE:t									{: RESULT = Type.fromName((String)t); ((AbstractTreeNode)RESULT).setLineCol(tleft, tright); :}
;
Index ::= LSQUARE Exp:e RSQUARE				{: RESULT = new ArrayIndex((Expression)e, ArrayIndex.AccessType.INDEX); :}
	| LSQUARE Exp:e RRANGE					{: RESULT = new ArrayIndex((Expression)e, ArrayIndex.AccessType.LEFT_RANGE); :}
	| LRANGE Exp:e RSQUARE					{: RESULT = new ArrayIndex((Expression)e, ArrayIndex.AccessType.RIGHT_RANGE); :}
	| LSQUARE Exp:e1 COLON Exp:e2 RSQUARE	{: RESULT = new ArrayIndex((Expression)e1, (Expression)e2, ArrayIndex.AccessType.LEFT_RIGHT_RANGE); :}
;
CommaExp ::= CommaExp:exps COMMA Exp:e		{: ((List<Expression>)exps).add((Expression)e); RESULT = exps; :}
	| Exp:e									{: RESULT = new ArrayList<Expression>(); ((List<Expression>)RESULT).add((Expression)e); :}
;
ArgList ::= Args:args						{: RESULT = args; :}
	| 										{: RESULT = new ArrayList<Argument>(); :}
;
Args ::= Args:args COMMA Arg:arg			{: ((List<Argument>)args).add((Argument)arg); RESULT = args; :}
	| Arg:arg								{: RESULT = new ArrayList<Argument>(); ((List<Argument>)RESULT).add((Argument)arg); :}
;
Arg ::= ID:id COLON:c VarType:t				{: RESULT = new Argument((String)id, (Type)t); ((AbstractTreeNode)RESULT).setLineCol(cleft, cright); :}
;
ClassBody ::= ClassBody:b DELIMITER Dec:d	{: ((List<FunctionOrVarDeclaration>)b).add((FuncDeclaration)d); RESULT = b; :}
	| ClassBody:b DELIMITER DVarN:d			{: ((List<FunctionOrVarDeclaration>)b).add((VarDeclaration)d); RESULT = b; :}
	| Dec:d									{: RESULT = new ArrayList<FunctionOrVarDeclaration>(); ((List<FunctionOrVarDeclaration>)RESULT).add((FuncDeclaration)d); :}
	| DVarN:d								{: RESULT = new ArrayList<FunctionOrVarDeclaration>(); ((List<FunctionOrVarDeclaration>)RESULT).add((VarDeclaration)d); :}
;
BlockBody ::= BlockBody:is DELIMITER Inst:i			{: ((List<Statement>)is).add((Statement)i); RESULT = is; :}
	| Inst:i										{: RESULT = new ArrayList<Statement>(); ((List<Statement>)RESULT).add((Statement)i); :}
	|												{: RESULT = new ArrayList<Statement>(); :}
;
