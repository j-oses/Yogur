package yogur.cup;

import java_cup.runtime.*;
import java.util.*;

import yogur.error.CompilationException;
import yogur.tree.*;
import yogur.tree.declaration.*;
import yogur.tree.declaration.declarator.*;
import yogur.tree.expression.*;
import yogur.tree.expression.identifier.*;
import yogur.tree.statement.*;

scan with {: return getScanner().next_token(); :};

parser code {:
	private List<CompilationException> exceptions = new ArrayList<>();

	public List<CompilationException> getExceptions() {
		return exceptions;
	}

	public void syntax_error(Symbol symbol) {
		exceptions.add(new CompilationException(symbol, CompilationException.Scope.SyntacticalAnalyzer));
	}
:}

terminal INT, BOOL, ID, TYPE, DELIMITER, COMMA;
terminal ASSIGN, SUM, SUBS, PROD, DIV, MOD, AND, OR, NOT, DOT, LRANGE, RRANGE, EQ, NEQ, GEQ, GT, LEQ, LT, COLON, ARROW;
terminal LPAREN, RPAREN, LSQUARE, RSQUARE, LBRACKET, RBRACKET;
terminal DEF, VAR, CLASS, IF, ELSE, WHILE, FOR, IN, TO;

non terminal S, Inst, Dec, DVar, DProc, DFunc, DClass, Block;
non terminal If, While, For, Ass;
non terminal Exp, Exp0, Exp1, Exp2, Exp3, Exp4, Exp5, Exp6, Exp7;
non terminal Declarator, Declarator0;
non terminal VarType, Index, CommaExp, ArgList, Args, Arg, ClassBody, BlockBody, Else;


S ::= S:p DELIMITER Inst:i				{: RESULT = new Program((Program)p, (StatementOrDeclaration)i); :}
	| S:p DELIMITER Dec:d				{: RESULT = new Program((Program)p, (StatementOrDeclaration)d); :}
	| S:p DELIMITER DClass:d			{: RESULT = new Program((Program)p, (StatementOrDeclaration)d); :}
	| S:p DELIMITER						{: RESULT = p; :}
	| Inst:i							{: RESULT = new Program((StatementOrDeclaration)i); :}
	| Dec:d 							{: RESULT = new Program((StatementOrDeclaration)d); :}
	| DClass:d 							{: RESULT = new Program((StatementOrDeclaration)d); :}
	| 									{: RESULT = new Program(); :}
;
Inst ::= If:i							{: RESULT = i; :}
	| While:i							{: RESULT = i; :}
	| For:i								{: RESULT = i; :}
	| Ass:i								{: RESULT = i; :}
	| Block:i							{: RESULT = i; :}
	| DVar:i							{: RESULT = i; :}
;
Dec ::= DProc:d							{: RESULT = d; :}
	| DFunc:d							{: RESULT = d; :}
;

DVar ::= VAR Arg:a														{: RESULT = new VarDeclaration((Argument)a); :}
	| VAR Arg:a ASSIGN Exp:e											{: RESULT = new VarDeclaration((Argument)a, (Expression)e); :}
;
DProc ::= DEF ID:id LPAREN ArgList:args RPAREN Block:b					{: RESULT = new FuncDeclaration((String)id, (List<Argument>)args, (Block)b); :}
;
DFunc ::= DEF ID:id LPAREN ArgList:args RPAREN ARROW Arg:rarg Block:b	{: RESULT = new FuncDeclaration((String)id, (List<Argument>)args, (Argument)rarg, (Block)b); :}
;
DClass ::= CLASS TYPE:t LBRACKET ClassBody:insts RBRACKET				{: RESULT = new ClassDeclaration(new BaseType((String)t), (List<FunctionOrVarDeclaration>)insts); :}
;
Block ::= LBRACKET BlockBody:insts RBRACKET								{: RESULT = new Block((List<Statement>)insts); :}
;

If ::= IF Exp:exp Block:b Else:elsee		{: RESULT = new IfStructure((Expression)exp, (Block)b, (Block)elsee); :}
;
Else ::= ELSE If:ife						{: List<Statement> insts = new ArrayList<Statement>(); insts.add((IfStructure)ife); RESULT = new Block(insts); :}
	| ELSE Block:b							{: RESULT = b; :}
	| 										{: RESULT = null; :}
;
While ::= WHILE Exp:e Block:b				{: RESULT = new WhileStructure((Expression)e, (Block)b); :}
;
For ::= FOR ID:id IN Exp:start TO Exp:end Block:b		{: RESULT = new ForStructure(new BaseDeclarator((String)id), (Expression)start, (Expression)end, (Block)b); :}
;
Ass ::= Declarator:d ASSIGN Exp:e				{: RESULT = new Assignation((Declarator)d, (Expression)e); :}
;

Declarator ::= Declarator:d DOT ID:id			{: RESULT = new DotDeclarator((Declarator)d, (String)id); :}
	| Declarator:d Index:i						{: RESULT = new ArrayDeclarator((Declarator)d, (ArrayIndex)i); :}
	| Declarator0:d								{: RESULT = d; :}
;
Declarator0 ::= LPAREN Declarator:d RPAREN		{: RESULT = d; :}
	| ID:id										{: RESULT = new BaseDeclarator((String)id); :}
;

Exp ::= Exp:e1 OR Exp0:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.OR); :}
	| Exp0:e					{: RESULT = e; :}
;
Exp0 ::= Exp0:e1 AND Exp1:e2	{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.AND); :}
	| Exp1:e					{: RESULT = e; :}
;
Exp1 ::= Exp1:e1 EQ Exp2:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.EQ); :}
	| Exp1:e1 NEQ Exp2:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.NEQ); :}
	| Exp2:e					{: RESULT = e; :}
;
Exp2 ::= Exp2:e1 LT Exp3:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.LT); :}
	| Exp2:e1 LEQ Exp3:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.LEQ); :}
	| Exp2:e1 GT Exp3:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.GT); :}
	| Exp2:e1 GEQ Exp3:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.GEQ); :}
	| Exp3:e					{: RESULT = e; :}
;
Exp3 ::= Exp3:e1 SUM Exp4:e2	{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.SUM); :}	
	| Exp3:e1 SUBS Exp4:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.SUBS); :}
	| Exp4:e					{: RESULT = e; :}
;
Exp4 ::= Exp4:e1 PROD Exp5:e2	{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.PROD); :}
	| Exp4:e1 DIV Exp5:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.DIV); :}
	| Exp4:e1 MOD Exp5:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.MOD); :}
	| Exp5:e					{: RESULT = e; :}
;
Exp5 ::= SUBS Exp5:e			{: RESULT = new UnaryOperation((Expression)e, UnaryOperation.Operator.NEG); :}
	| NOT Exp5:e				{: RESULT = new UnaryOperation((Expression)e, UnaryOperation.Operator.NOT); :}
	| Exp6:e					{: RESULT = e; :}
;
Exp6 ::= Exp6:e DOT ID:id					{: RESULT = new DotIdentifier((Expression)e, (String)id); :}
	| Exp6:e Index:i						{: RESULT = new ArrayIdentifier((Expression)e, (ArrayIndex)i); :}
	| Exp6:e LPAREN CommaExp:exps RPAREN	{: RESULT = new FunctionCall((Expression)e, (List<Expression>)exps); :}
	| Exp6:e LPAREN RPAREN					{: RESULT = new FunctionCall((Expression)e, new ArrayList<Expression>()); :}
	| Exp7:e								{: RESULT = e; :}
;
Exp7 ::= LPAREN Exp:e RPAREN	{: RESULT = e; :}
	| ID:id						{: RESULT = new BaseIdentifier((String)id); :}
	| INT:intLit				{: RESULT = new Constant(intLit); :}
	| BOOL:boolLit				{: RESULT = new Constant(boolLit); :}
;

VarType ::= VarType:t LSQUARE INT:i RSQUARE		{: RESULT = new ArrayType((Type)t, (Integer)i); :}
	| TYPE:t									{: RESULT = new BaseType((String)t); :}
;
Index ::= LSQUARE Exp:e RSQUARE				{: RESULT = new ArrayIndex((Expression)e, ArrayIndex.AccessType.INDEX); :}
	| LSQUARE Exp:e RRANGE					{: RESULT = new ArrayIndex((Expression)e, ArrayIndex.AccessType.LEFT_RANGE); :}
	| LRANGE Exp:e RSQUARE					{: RESULT = new ArrayIndex((Expression)e, ArrayIndex.AccessType.RIGHT_RANGE); :}
	| LSQUARE Exp:e1 COLON Exp:e2 RSQUARE	{: RESULT = new ArrayIndex((Expression)e1, (Expression)e2, ArrayIndex.AccessType.LEFT_RIGHT_RANGE); :}
;
CommaExp ::= CommaExp:exps COMMA Exp:e		{: ((List<Expression>)exps).add((Expression)e); RESULT = exps; :}
	| Exp:e									{: RESULT = new ArrayList<Expression>(); ((List<Expression>)RESULT).add((Expression)e); :}
;
ArgList ::= Args:args						{: RESULT = args; :}
	| 										{: RESULT = new ArrayList<Argument>(); :}
;
Args ::= Args:args COMMA Arg:arg			{: ((List<Argument>)args).add((Argument)arg); RESULT = args; :}
	| Arg:arg								{: RESULT = new ArrayList<Argument>(); ((List<Argument>)RESULT).add((Argument)arg); :}
;
Arg ::= ID:id COLON VarType:t				{: RESULT = new Argument((String)id, (Type)t); :}
;
ClassBody ::= ClassBody:b DELIMITER Dec:d	{: ((List<FunctionOrVarDeclaration>)b).add((FuncDeclaration)d); RESULT = b; :}
	| ClassBody:b DELIMITER DVar:d			{: ((List<FunctionOrVarDeclaration>)b).add((VarDeclaration)d); RESULT = b; :}
	| Dec:d									{: RESULT = new ArrayList<FunctionOrVarDeclaration>(); ((List<FunctionOrVarDeclaration>)RESULT).add((FuncDeclaration)d); :}
	| DVar:d								{: RESULT = new ArrayList<FunctionOrVarDeclaration>(); ((List<FunctionOrVarDeclaration>)RESULT).add((VarDeclaration)d); :}
;
BlockBody ::= BlockBody:is DELIMITER Inst:i			{: ((List<Statement>)is).add((Statement)i); RESULT = is; :}
	| Inst:i										{: RESULT = new ArrayList<Statement>(); ((List<Statement>)RESULT).add((Statement)i); :}
	|												{: RESULT = new ArrayList<Statement>(); :}
;
