package yogur.cup;

import java_cup.runtime.*;
import java.util.*;

import yogur.error.CompilationException;
import yogur.tree.*;
import yogur.tree.declaration.*;
import yogur.tree.expression.*;
import yogur.tree.expression.identifier.*;
import yogur.tree.statement.*;

action code {:
:}

scan with {: return getScanner().next_token(); :};

parser code {:
	private List<CompilationException> exceptions = new ArrayList<>();

	public List<CompilationException> getExceptions() {
		return exceptions;
	}

	public void syntax_error(Symbol symbol) {
		exceptions.add(new CompilationException(symbol, CompilationException.Scope.SyntacticalAnalyzer));
	}
:}

terminal INT, BOOL, ID, TYPE, DELIMITER, COMMA;
terminal ASSIGN, SUM, SUBS, PROD, DIV, MOD, AND, OR, NOT, DOT, LRANGE, RRANGE, EQ, NEQ, GEQ, GT, LEQ, LT, COLON, ARROW;
terminal LPAREN, RPAREN, LSQUARE, RSQUARE, LBRACKET, RBRACKET;
terminal DEF, VAR, CLASS, IF, ELSE, WHILE, FOR, IN, TO;

non terminal S, Inst, Dec, DVar, DProc, DFunc, DClass, Block;
non terminal If, While, For, Ass;
non terminal Exp, Exp1, Exp2, Exp3, Exp4, Exp5, Exp6, Exp7;
non terminal VarType, VarId, DotId, Index, FuncCall, CommaExp, FuncId, ArgList, Args, Arg, ClassBody, BlockBody, Else;


S ::= S:p DELIMITER Inst:i				{: RESULT = new Program((Program)p, (StatementOrDeclaration)i); :}
	| S:p DELIMITER Dec:d				{: RESULT = new Program((Program)p, (StatementOrDeclaration)d); :}
	| S:p DELIMITER DClass:d			{: RESULT = new Program((Program)p, (StatementOrDeclaration)d); :}
	| S:p DELIMITER						{: RESULT = p; :}
	| Inst:i							{: RESULT = new Program((StatementOrDeclaration)i); :}
	| Dec:d 							{: RESULT = new Program((StatementOrDeclaration)d); :}
	| DClass:d 							{: RESULT = new Program((StatementOrDeclaration)d); :}
	| 									{: RESULT = new Program(); :}
;
Inst ::= If:i							{: RESULT = i; :}
	| While:i							{: RESULT = i; :}
	| For:i								{: RESULT = i; :}
	| Ass:i								{: RESULT = i; :}
	| Block:i							{: RESULT = i; :}
	| DVar:i							{: RESULT = i; :}
;
Dec ::= DProc:d							{: RESULT = d; :}
	| DFunc:d							{: RESULT = d; :}
;

DVar ::= VAR Arg
	| VAR Arg ASSIGN Exp
;
DProc ::= DEF FuncId LPAREN ArgList RPAREN Block
;
DFunc ::= DEF FuncId LPAREN ArgList RPAREN ARROW Arg Block
;
DClass ::= CLASS TYPE LBRACKET ClassBody RBRACKET
;
Block ::= LBRACKET BlockBody RBRACKET
;

If ::= IF Exp:exp Block:b Else:elsee		{: RESULT = new IfStructure((Expression)exp, (Block)b, (Block)elsee); :}
;
Else ::= ELSE If:ife						{: RESULT = new Block((Block)ife); :}
	| ELSE Block:b							{: RESULT = b; :}
;
While ::= WHILE Exp:e Block:b				{: RESULT = new WhileStructure((Expression)e, (Block)b); :}
;
For ::= FOR ID:id IN Exp:start TO Exp:end Block:b		{: RESULT = new ForStructure(new BaseIdentifier((String)id), (Expression)start, (Expression)end, (Block)b); :}
;
Ass ::= VarId:id ASSIGN Exp:e				{: RESULT = new Assignation((VarIdentifier)id, (Expression)e); :}
;

Exp ::= SUBS Exp:e				{: RESULT = new UnaryOperation((Expression)e, UnaryOperation.Operator.NEG); :}
	| NOT Exp:e					{: RESULT = new UnaryOperation((Expression)e, UnaryOperation.Operator.NOT); :}
	| Exp1:e					{: RESULT = e; :}
;
Exp1 ::= Exp1:e1 PROD Exp2:e2	{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.PROD); :}
	| Exp1:e1 DIV Exp2:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.DIV); :}
	| Exp1:e1 MOD Exp2:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.MOD); :}
	| Exp2:e					{: RESULT = e; :}
;
Exp2 ::= Exp2:e1 SUM Exp3:e2	{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.SUM); :}	
	| Exp2:e1 SUBS Exp3:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.SUBS); :}
	| Exp3:e					{: RESULT = e; :}
;
Exp3 ::= Exp3:e1 LT Exp4:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.LT); :}
	| Exp3:e1 LEQ Exp4:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.LEQ); :}
	| Exp3:e1 GT Exp4:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.GT); :}
	| Exp3:e1 GEQ Exp4:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.GEQ); :}
	| Exp4:e					{: RESULT = e; :}
;
Exp4 ::= Exp4:e1 EQ Exp5:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.EQ); :}
	| Exp4:e1 NEQ Exp5:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.NEQ); :}
	| Exp5:e					{: RESULT = e; :}
;
Exp5 ::= Exp5:e1 AND Exp6:e2	{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.AND); :}
	| Exp6:e					{: RESULT = e; :}
;
Exp6 ::= Exp6:e1 OR Exp7:e2		{: RESULT = new BinaryOperation((Expression)e1, (Expression)e2, BinaryOperation.Operator.OR); :}
	| Exp7:e					{: RESULT = e; :}
;
Exp7 ::= LPAREN Exp:e RPAREN	{: RESULT = e; :}
	| VarId:id					{: RESULT = id; :}
	| FuncCall:funcc			{: RESULT = funcc; :}
	| INT:intLit				{: RESULT = new Constant(intLit); :}
	| BOOL:boolLit				{: RESULT = new Constant(boolLit); :}
;

VarType ::= VarType:t LSQUARE INT:i RSQUARE		{: RESULT = new ArrayType((Type)t, (Integer)i); :}
	| TYPE:t									{: RESULT = new BaseType((String)t); :}
;
VarId ::= VarId:id Index:i		{: RESULT = new ArrayIdentifier((VarIdentifier)id, (ArrayIndex)i); :}
	| DotId:did					{: RESULT = did; :}
;
DotId ::= DotId:ids DOT ID:id	{: RESULT = new DotIdentifier((DotIdentifier)ids, (BaseIdentifier)id); :}
	| ID:id						{: RESULT = new BaseIdentifier((String)id); :}
;
Index ::= LSQUARE Exp:e RSQUARE				{: RESULT = new ArrayIndex((Expression)e, ArrayIndex.AccessType.INDEX); :}
	| LSQUARE Exp:e RRANGE					{: RESULT = new ArrayIndex((Expression)e, ArrayIndex.AccessType.LEFT_RANGE); :}
	| LRANGE Exp:e RSQUARE					{: RESULT = new ArrayIndex((Expression)e, ArrayIndex.AccessType.RIGHT_RANGE); :}
	| LSQUARE Exp:e1 COLON Exp:e2 RSQUARE	{: RESULT = new ArrayIndex((Expression)e1, (Expression)e2, ArrayIndex.AccessType.LEFT_RIGHT_RANGE); :}
;
FuncCall ::= DotId LPAREN CommaExp RPAREN
	| DotId LPAREN RPAREN
;
CommaExp ::= CommaExp COMMA Exp
	| Exp
;
FuncId ::= ID
;
ArgList ::= Args
	| 
;
Args ::= Args COMMA Arg
;
Arg ::= ID COLON VarType
;
ClassBody ::= ClassBody DELIMITER Dec
	| ClassBody DELIMITER DVar
	| Dec
	| DVar
;
BlockBody ::= BlockBody DELIMITER Inst
	| Inst
;
